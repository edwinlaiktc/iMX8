# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_libfdt')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_libfdt')
    _libfdt = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libfdt', [dirname(__file__)])
        except ImportError:
            import _libfdt
            return _libfdt
        try:
            _mod = imp.load_module('_libfdt', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _libfdt = swig_import_helper()
    del swig_import_helper
else:
    import _libfdt
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def Raise(errnum):
    raise ValueError('Error %s' % fdt_strerror(errnum))

def Name(fdt, offset):
    name, len = fdt_get_name(fdt, offset)
    return name

def String(fdt, offset):
    offset = fdt32_to_cpu(offset)
    name = fdt_string(fdt, offset)
    return name

def swap32(x):
    return (((x << 24) & 0xFF000000) |
            ((x <<  8) & 0x00FF0000) |
            ((x >>  8) & 0x0000FF00) |
            ((x >> 24) & 0x000000FF))

def fdt32_to_cpu(x):
    return swap32(x)

def Data(prop):
    set_prop(prop)
    return get_prop_data()

class fdt_property(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fdt_property, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fdt_property, name)
    __repr__ = _swig_repr
    __swig_setmethods__["tag"] = _libfdt.fdt_property_tag_set
    __swig_getmethods__["tag"] = _libfdt.fdt_property_tag_get
    if _newclass:
        tag = _swig_property(_libfdt.fdt_property_tag_get, _libfdt.fdt_property_tag_set)
    __swig_setmethods__["len"] = _libfdt.fdt_property_len_set
    __swig_getmethods__["len"] = _libfdt.fdt_property_len_get
    if _newclass:
        len = _swig_property(_libfdt.fdt_property_len_get, _libfdt.fdt_property_len_set)
    __swig_setmethods__["nameoff"] = _libfdt.fdt_property_nameoff_set
    __swig_getmethods__["nameoff"] = _libfdt.fdt_property_nameoff_get
    if _newclass:
        nameoff = _swig_property(_libfdt.fdt_property_nameoff_get, _libfdt.fdt_property_nameoff_set)
    __swig_setmethods__["data"] = _libfdt.fdt_property_data_set
    __swig_getmethods__["data"] = _libfdt.fdt_property_data_get
    if _newclass:
        data = _swig_property(_libfdt.fdt_property_data_get, _libfdt.fdt_property_data_set)

    def __init__(self):
        this = _libfdt.new_fdt_property()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _libfdt.delete_fdt_property
    __del__ = lambda self: None
fdt_property_swigregister = _libfdt.fdt_property_swigregister
fdt_property_swigregister(fdt_property)


def set_prop(prop):
    return _libfdt.set_prop(prop)
set_prop = _libfdt.set_prop

def get_prop_data():
    return _libfdt.get_prop_data()
get_prop_data = _libfdt.get_prop_data

def fdt_offset_ptr(fdt, offset, checklen):
    return _libfdt.fdt_offset_ptr(fdt, offset, checklen)
fdt_offset_ptr = _libfdt.fdt_offset_ptr

def fdt_path_offset(fdt, path):
    return _libfdt.fdt_path_offset(fdt, path)
fdt_path_offset = _libfdt.fdt_path_offset

def fdt_first_property_offset(fdt, nodeoffset):
    return _libfdt.fdt_first_property_offset(fdt, nodeoffset)
fdt_first_property_offset = _libfdt.fdt_first_property_offset

def fdt_next_property_offset(fdt, offset):
    return _libfdt.fdt_next_property_offset(fdt, offset)
fdt_next_property_offset = _libfdt.fdt_next_property_offset

def fdt_strerror(errval):
    return _libfdt.fdt_strerror(errval)
fdt_strerror = _libfdt.fdt_strerror

def fdt_get_property_by_offset(fdt, offset):
    return _libfdt.fdt_get_property_by_offset(fdt, offset)
fdt_get_property_by_offset = _libfdt.fdt_get_property_by_offset

def fdt_get_name(fdt, nodeoffset):
    return _libfdt.fdt_get_name(fdt, nodeoffset)
fdt_get_name = _libfdt.fdt_get_name

def fdt_string(fdt, stroffset):
    return _libfdt.fdt_string(fdt, stroffset)
fdt_string = _libfdt.fdt_string

def fdt_first_subnode(fdt, offset):
    return _libfdt.fdt_first_subnode(fdt, offset)
fdt_first_subnode = _libfdt.fdt_first_subnode

def fdt_next_subnode(fdt, offset):
    return _libfdt.fdt_next_subnode(fdt, offset)
fdt_next_subnode = _libfdt.fdt_next_subnode

def fdt_delprop(fdt, nodeoffset, name):
    return _libfdt.fdt_delprop(fdt, nodeoffset, name)
fdt_delprop = _libfdt.fdt_delprop

def fdt_pack(fdt):
    return _libfdt.fdt_pack(fdt)
fdt_pack = _libfdt.fdt_pack

def fdt_totalsize(fdt):
    return _libfdt.fdt_totalsize(fdt)
fdt_totalsize = _libfdt.fdt_totalsize

def fdt_off_dt_struct(fdt):
    return _libfdt.fdt_off_dt_struct(fdt)
fdt_off_dt_struct = _libfdt.fdt_off_dt_struct
# This file is compatible with both classic and new-style classes.

cvar = _libfdt.cvar

