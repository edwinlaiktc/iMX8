# Do not edit this file, it will be overwritten on updates
#

# import names for PCI storage controllers
#
SUBSYSTEM=="pci", ACTION=="add|change", ENV{ID_MODEL_FROM_DATABASE}=="", ATTR{class}=="0x01*", IMPORT{program}="pci-db %p"

# Set eSATA port type for known eSATA CardBus adapters - first we want to ensure
# the device is on a cardbus controller (upper PCI device) - then we check
# vid/pid (lower PCI device)
#
SUBSYSTEM=="scsi_host", ATTRS{class}=="0x060700", GOTO="ata_port_cardbus"
GOTO="ata_port_cardbus_end"
LABEL="ata_port_cardbus"
# Mass storage controller: Silicon Image, Inc. SiI 3512 [SATALink/SATARaid] Serial ATA Controller (rev 01)
#
SUBSYSTEMS=="pci", ATTRS{vendor}=="0x1095", ATTRS{device}=="0x3512", ENV{UDISKS_ATA_PORT_CONNECTOR_TYPE}="ata_sata_external"
LABEL="ata_port_cardbus_end"

# probe SAS expanders
#
# (hmm, this might be racy, we might not have the BSG device just yet - if
#  this is the case we can trigger a 'change' on the sas_expander device
#  when the bsg device appears)
#
SUBSYSTEM=="sas_expander", ACTION=="add|change", IMPORT{program}="udisks-probe-sas-expander /sys/%p"

##############################################################################################################

# from here on, we only care about block devices
ACTION!="add|change", GOTO="udisks_end"
SUBSYSTEM!="block", GOTO="udisks_end"
KERNEL=="ram*", GOTO="udisks_end"

# Mark devices that shouldn't be automounted / autoassembled etc.
#
# Deny all, then punch holes for what looks like physical drives
# (TODO: this heuristic might need some work)
#

ENV{UDISKS_PRESENTATION_NOPOLICY}="1"
KERNEL=="sd*|hd*|sr*|mmcblk*|mspblk*", ENV{UDISKS_PRESENTATION_NOPOLICY}="0"

##############################################################################################################

# we only care about change events on device-mapper
# devices - never touch the device on add events
KERNEL=="dm-*", ACTION!="change", GOTO="udisks_end"

# honor the flag that device-mapper sets if the device should be ignored
ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}=="1", GOTO="udisks_end"
ENV{DM_UDEV_DISABLE_DISK_RULES_FLAG}=="1", GOTO="udisks_end"

# import UDISKS_DM_* and UDISKS_LVM2_* properties - the long-term plan is to make the lvm2 and
# device-mapper packages provide this information
#
KERNEL=="dm-*", IMPORT{program}="udisks-dm-export %M %m"

# Make udevd synthesize a 'change' uevent when last opener of a rw-fd closes the fd - this
# should be part of the device-mapper rules
KERNEL=="dm-*", OPTIONS+="watch"

##############################################################################################################
# Probe LVM2 Physical Volumes - this will eventually be part of the LVM2 package

ENV{ID_FS_TYPE}=="LVM2_member", TEST=="/lib/udev/udisks-lvm-pv-export", IMPORT{program}="udisks-lvm-pv-export $env{ID_FS_UUID}"

##############################################################################################################

# Probe for partition tables; this really should be part of udev / util-linux-ng
#

# skip rules for inappropriate block devices
KERNEL=="fd*|mtd*|nbd*|gnbd*|btibm*", GOTO="probe_parttable_end"

# never access non-cdrom removable ide devices, the drivers are causing event loops on open()
KERNEL=="hd*[!0-9]", ATTR{removable}=="1", SUBSYSTEMS=="ide", ATTRS{media}=="disk|floppy", GOTO="probe_parttable_end"
KERNEL=="hd*[0-9]", ATTR{removable}=="1", GOTO="probe_parttable_end"

# don't scan for partition tables on empty discs
KERNEL=="sr*", ENV{ID_CDROM_MEDIA}!="?*", GOTO="probe_parttable_end"

# skip non-data discs (see https://bugzilla.kernel.org/show_bug.cgi?id=15757 for the udev bits)
KERNEL=="sr*", ENV{ID_CDROM_MEDIA_TRACK_COUNT_DATA}=="", GOTO="probe_parttable_end"

# scan for partition tables both on whole-disk and partitions
#
IMPORT{program}="udisks-part-id $tempnode"

LABEL="probe_parttable_end"

##############################################################################################################

# pick up data from MD components; this REALLY should be done by rules installed
# by mdadm or the kernel package
#
ENV{ID_FS_TYPE}!="linux_raid_member", GOTO="md_end"

# avoid probing if it has already been done earlier
#
ENV{MD_LEVEL}!="", GOTO="md_end"
TEST=="/sbin/mdadm", IMPORT{program}="/sbin/mdadm --examine --export $tempnode"

LABEL="md_end"

##############################################################################################################

# Check if a disk is ATA SMART capable
#

# USB ATA enclosures with a SAT layer
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="usb", ENV{DEVTYPE}=="disk", IMPORT{program}="udisks-probe-ata-smart $tempnode"

# ATA disks driven by libata
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="ata", ENV{DEVTYPE}=="disk", IMPORT{program}="udisks-probe-ata-smart $tempnode"

# ATA disks connected via SAS (not driven by libata)
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="scsi", ENV{DEVTYPE}=="disk", ENV{ID_VENDOR}=="ATA", IMPORT{program}="udisks-probe-ata-smart $tempnode"


# Example rule for tagging a device with a specific media type. Where and
# how to store this database needs some thought.
#
SUBSYSTEMS=="usb", ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:0", ENV{ID_DRIVE_FLASH_CF}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:1", ENV{ID_DRIVE_FLASH_MS}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:2", ENV{ID_DRIVE_FLASH_SM}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:3", ENV{ID_DRIVE_FLASH_SD}="1"

SUBSYSTEMS=="usb", ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:0", ENV{ID_DRIVE_FLASH_CF}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:1", ENV{ID_DRIVE_FLASH_SM}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:2", ENV{ID_DRIVE_FLASH_SD}="1"
SUBSYSTEMS=="usb", ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:3", ENV{ID_DRIVE_FLASH_MS}="1"

# APPLE SD Card Reader (MacbookPro5,4)
#
SUBSYSTEMS=="usb", ATTRS{idVendor}=="05ac", ATTRS{idProduct}=="8403", ENV{ID_DRIVE_FLASH_SD}="1"

# Realtek card readers
DRIVERS=="rts_pstor", ENV{ID_DRIVE_FLASH_SD}="1"
DRIVERS=="rts_bpp", ENV{ID_DRIVE_FLASH_SD}="1"

# Common theme
#
SUBSYSTEMS=="usb", ENV{ID_MODEL}=="*SD_Reader*", ENV{ID_DRIVE_FLASH_SD}="1"
SUBSYSTEMS=="usb", ENV{ID_MODEL}=="*Reader*SD*", ENV{ID_DRIVE_FLASH_SD}="1"
SUBSYSTEMS=="usb", ENV{ID_MODEL}=="*CF_Reader*", ENV{ID_DRIVE_FLASH_CF}="1"
SUBSYSTEMS=="usb", ENV{ID_MODEL}=="*SM_Reader*", ENV{ID_DRIVE_FLASH_SM}="1"
SUBSYSTEMS=="usb", ENV{ID_MODEL}=="*MS_Reader*", ENV{ID_DRIVE_FLASH_MS}="1"

# TODO: figure out if the drive supports SD and SDHC and what the current
# kind of media is - right now we just assume SD
KERNEL=="mmcblk[0-9]", SUBSYSTEMS=="mmc", ENV{DEVTYPE}=="disk", ENV{ID_DRIVE_FLASH_SD}="1", ENV{ID_DRIVE_MEDIA_FLASH_SD}="1"
KERNEL=="mspblk[0-9]", SUBSYSTEMS=="memstick", ENV{DEVTYPE}=="disk", ENV{ID_DRIVE_FLASH_MS}="1", ENV{ID_DRIVE_MEDIA_FLASH_MS}="1"

##############################################################################################################

# If previous rules did not set an icon, provide a default one for media players

ENV{UDISKS_PRESENTATION_ICON_NAME}=="?*", GOTO="udisks_media_player_end"

ENV{ID_MEDIA_PLAYER}=="?*", ENV{UDISKS_PRESENTATION_ICON_NAME}="multimedia-player"
ENV{ID_MEDIA_PLAYER}=="apple-ipod", ENV{UDISKS_PRESENTATION_ICON_NAME}="multimedia-player-ipod"

# Apple iPod Video
#
SUBSYSTEMS=="usb", ATTRS{idVendor}=="05ac", ATTRS{idProduct}=="1209", ENV{UDISKS_PRESENTATION_ICON_NAME}="multimedia-player-ipod-white"

LABEL="udisks_media_player_end"

##############################################################################################################

# PC floppy drives
#
KERNEL=="fd*", ENV{ID_DRIVE_FLOPPY}="1"

# USB floppy drives
#
SUBSYSTEMS=="usb", ATTRS{bInterfaceClass}=="08", ATTRS{bInterfaceSubClass}=="04", ENV{ID_DRIVE_FLOPPY}="1"

# ATA Zip drives
#
ENV{ID_VENDOR}=="*IOMEGA*", ENV{ID_MODEL}=="*ZIP*", ENV{ID_DRIVE_FLOPPY_ZIP}="1"

##############################################################################################################

# Partitions which desktops should not display
#

# Apple Bootstrap partitions
ENV{UDISKS_PARTITION_SCHEME}=="apm", ENV{UDISKS_PARTITION_TYPE}=="Apple_Bootstrap", ENV{UDISKS_PRESENTATION_HIDE}="1"

# special MBR partition types (EFI, hidden, etc.)
# see http://www.win.tue.nl/~aeb/partitions/partition_types-1.html
ENV{UDISKS_PARTITION_SCHEME}=="mbr", \
  ENV{UDISKS_PARTITION_TYPE}=="0x00|0x11|0x12|0x14|0x16|0x17|0x1b|0x1c|0x1e|0x27|0x3d|0x84|0x8d|0x90|0x91|0x92|0x93|0x97|0x98|0x9a|0x9b|0xbb|0xc2|0xc3|0xdd|0xef", \
  ENV{UDISKS_PRESENTATION_HIDE}="1"

# special GUID-identified partition types
# see http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
ENV{UDISKS_PARTITION_SCHEME}=="gpt", \
  ENV{UDISKS_PARTITION_TYPE}=="C12A7328-F81F-11D2-BA4B-00A0C93EC93B|21686148-6449-6E6F-744E-656564454649", \
  ENV{UDISKS_PRESENTATION_HIDE}="1"

# APM recovery/tool partitions which are useless on Linux
ENV{UDISKS_PARTITION_SCHEME}=="apm", \
  ENV{ID_CDROM}=="?*", ENV{ID_FS_TYPE}=="udf", ENV{ID_FS_LABEL}=="WD_SmartWare", \
  ENV{UDISKS_PRESENTATION_HIDE}="1"

# recovery partitions (taken from old hal rules)
ENV{ID_FS_TYPE}=="ntfs|vfat", \
  ENV{ID_FS_LABEL}=="RECOVERY|HP_RECOVERY|Recovery Partition|DellUtility|DellRestore|IBM_SERVICE|SERVICEV001|SERVICEV002|SYSTEM RESERVED", \
  ENV{UDISKS_PRESENTATION_HIDE}="1"

# read-only non-Linux software installer partitions
ENV{ID_VENDOR}=="Sony", ENV{ID_MODEL}=="PRS*Launcher", ENV{UDISKS_PRESENTATION_HIDE}="1"

##############################################################################################################


LABEL="udisks_end"
